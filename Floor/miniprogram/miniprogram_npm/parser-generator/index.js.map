{"version":3,"sources":["parser-generator.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\n/**\n * JavaScript Parsing Library\n *\n * @copyright 2007 Dan Yoder, All Rights Reserved\n * @author Dan Yoder\n * @author Stephen Riesenberg\n * @version 0.6\n * @license MIT\n * @link http://code.google.com/p/cruiser/wiki/Parsing\n * @link https://github.com/sjohnr/parser-generator.js\n */\nvar Parser = {\n  Exception: function(s) {\n    this.message = \"Parse error at '\" + s.substring(0, 10) + \" ...'\";\n  }\n};\n\nfunction parseRegex(r) {\n  return (typeof r == \"string\") ? r : r.toString().match(/^\\/(.*)\\/$/)[1];\n}\n\nvar $P = Parser;\nvar o = $P.Operators = {\n  //\n  // Tokenizers\n  //\n  rtoken: function(r) { // regex token\n    return function(s) {\n      var mx = s.match(r);\n      if (mx) {\n        return ([ mx[0], s.substring(mx[0].length) ]);\n      } else {\n        throw new $P.Exception(s);\n      }\n    };\n  },\n  stoken: function(r) { // string token\n    return o.rtoken(new RegExp(\"^\" + parseRegex(r)));\n  },\n  vtoken: function() { // vector regex token\n    var px = arguments;\n    return function(s) {\n      var qx = [], rx = [ null, s ];\n      for (var i = 0; i < px.length; i++) {\n        rx = o.rtoken(px[i])(rx[1]);\n        qx.push(rx[0]);\n      }\n      return [ qx, rx[1] ];\n    };\n  },\n  token: function(r) { // whitespace-eating token\n    var xfn = o.vtoken(/^\\s*/, new RegExp(\"^\" + parseRegex(r)), /^\\s*/);\n    return function(s) {\n      var rx = xfn.call(this, s);\n      if (window.console) { // log parsing, for beneficial debug feedback\n        console.log(\"Parsing token: \\\"\"+rx[0][1]+\"\\\"\");\n      }\n      return [ rx[0][1].trim(), rx[1] ];\n    };\n  },\n\n  //\n  // Atomic Operators\n  //\n  until: function(p) {\n    return function(s) {\n      var qx = [], rx = null;\n      while (s.length) {\n        try {\n          rx = p.call(this, s);\n        } catch (e) {\n          qx.push(rx[0]);\n          s = rx[1];\n          continue;\n        }\n        break;\n      }\n      return [ qx, s ];\n    };\n  },\n  many: function(p) {\n    return function(s) {\n      var rx = [], r = null;\n      while (s.length) {\n        try {\n          r = p.call(this, s);\n        } catch (e) {\n          return [ rx, s ];\n        }\n        rx.push(r[0]);\n        s = r[1];\n      }\n      return [ rx, s ];\n    };\n  },\n\n  // generator operators -- see below\n  optional: function(p) {\n    return function(s) {\n      var r = null;\n      try {\n        r = p.call(this, s);\n      } catch (e) {\n        return [ null, s ];\n      }\n      return [ r[0], r[1] ];\n    };\n  },\n  not: function(p) {\n    return function(s) {\n      try {\n        p.call(this, s);\n      } catch (e) {\n        return [null, s];\n      }\n      throw new $P.Exception(s);\n    };\n  },\n  ignore: function(p) {\n    return p ? function(s) {\n      var r = p.call(this, s);\n      return [null, r[1]];\n    } : null;\n  },\n  product: function() {\n    var px = arguments[0], qx = Array.prototype.slice.call(arguments, 1), rx = [];\n    for (var i = 0 ; i < px.length ; i++) {\n      rx.push(o.each(px[i], qx));\n    }\n    return rx;\n  },\n  cache: function(rule) {\n    var cache = {}, r = null;\n    return function(s) {\n      try {\n        r = cache[s] = (cache[s] || rule.call(this, s));\n      } catch (e) {\n        r = cache[s] = e;\n      }\n      if (r instanceof $P.Exception) {\n        throw r;\n      } else {\n        return r;\n      }\n    };\n  },\n\n  // vector operators -- see below\n  any: function() {\n    var px = arguments;\n    return function(s) {\n      var r = null;\n      for (var i = 0; i < px.length; i++) {\n        if (px[i] === null) {\n          continue;\n        }\n        try {\n          r = (px[i].call(this, s));\n        } catch (e) {\n          r = null;\n        }\n        if (r) {\n          return r;\n        }\n      }\n      throw new $P.Exception(s);\n    };\n  },\n  each: function() {\n    var px = arguments;\n    return function(s) {\n      var rx = [], r = null;\n      for (var i = 0; i < px.length ; i++) {\n        if (px[i] === null) {\n          continue;\n        }\n        try {\n          r = (px[i].call(this, s));\n        } catch (e) {\n          throw new $P.Exception(s);\n        }\n        rx.push(r[0]);\n        s = r[1];\n      }\n      return [ rx, s ];\n    };\n  },\n  all: function() {\n    return o.each(o.optional(arguments));\n  },\n\n  // delimited operators\n  pair: function(p1, p2, d) {\n    d = d || o.rtoken(/^\\s*/);\n    var xfn = o.each(p1, o.ignore(d), p2);\n    return function(s) {\n      var rx = xfn.call(this, s);\n      return [ [ rx[0][0], rx[0][2] ], rx[1] ];\n    };\n  },\n  sequence: function(px, d, c) {\n    d = d || o.rtoken(/^\\s*/);\n    c = c || null;\n\n    if (px.length === 1) {\n      return px[0];\n    }\n    return function(s) {\n      var r = null, q = null;\n      var rx = [];\n      for (var i = 0; i < px.length ; i++) {\n        try {\n          r = px[i].call(this, s);\n        } catch (e) {\n          break;\n        }\n        rx.push(r[0]);\n        try {\n          q = d.call(this, r[1]);\n        } catch (ex) {\n          q = null;\n          break;\n        }\n        s = q[1];\n      }\n      if (!r) {\n        throw new $P.Exception(s);\n      }\n      if (q) {\n        throw new $P.Exception(q[1]);\n      }\n      if (c) {\n        try {\n          r = c.call(this, r[1]);\n        } catch (ey) {\n          throw new $P.Exception(r[1]);\n        }\n      }\n      return [ rx, (r?r[1]:s) ];\n    };\n  },\n\n  //\n  // Composite Operators\n  //\n  between: function(d1, p, d2) {\n    d2 = d2 || d1;\n    var xfn = o.each(o.ignore(d1), p, o.ignore(d2));\n    return function(s) {\n      var rx = xfn.call(this, s);\n      return [ rx[0][1], rx[1] ];\n    };\n  },\n  list: function(p, d, c) {\n    d = d || o.rtoken(\",\");\n    c = c || false;\n\n    var xfn = (p instanceof Array) ?\n        o.each(o.product(p.slice(0, -1), o.ignore(d)), c ? o.optional(p.slice(-1)) : p.slice(-1)) :\n        o.each(o.many(o.each(p, o.ignore(d))), c ? o.optional(p) : p);\n    return function(s) {\n      var r = xfn.call(this, s), r0 = r[0][0], r1 = r[0][1], rx = [];\n      for (var i = 0; i < r0.length; i++) {\n        rx.push(r0[i][0]);\n      }\n      if (r1) {\n        rx.push(r1);\n      }\n      return [ rx, r[1] ];\n    };\n  },\n  set: function(px, d, c) {\n    d = d || o.rtoken(/^\\s*/);\n    c = c || null;\n    return function(s) {\n      // r is the current match, best the current 'best' match\n      // which means it parsed the most amount of input\n      var r = null, p = null, q = null, rx = null, best = [[], s], last = false;\n\n      // go through the rules in the given set\n      for (var i = 0; i < px.length ; i++) {\n\n        // last is a flag indicating whether this must be the last element\n        // if there is only 1 element, then it MUST be the last one\n        q = null;\n        p = null;\n        r = null;\n        last = (px.length === 1);\n        // first, we try simply to match the current pattern\n        // if not, try the next pattern\n        try {\n          r = px[i].call(this, s);\n        } catch (e) {\n          continue;\n        }\n\n        // since we are matching against a set of elements, the first\n        // thing to do is to add r[0] to matched elements\n        rx = [[r[0]], r[1]];\n\n        // if we matched and there is still input to parse and\n        // we don't already know this is the last element,\n        // we're going to next check for the delimiter ...\n        // if there's none, or if there's no input left to parse\n        // than this must be the last element after all ...\n        if (r[1].length > 0 && ! last) {\n          try {\n            q = d.call(this, r[1]);\n          } catch (ex) {\n            last = true;\n          }\n        } else {\n          last = true;\n        }\n\n        // if we parsed the delimiter and now there's no more input,\n        // that means we shouldn't have parsed the delimiter at all\n        // so don't update r and mark this as the last element ...\n        if (!last && q[1].length === 0) {\n          last = true;\n        }\n\n\n        // so, if this isn't the last element, we're going to see if\n        // we can get any more matches from the remaining (unmatched)\n        // elements ...\n        if (!last) {\n\n          // build a list of the remaining rules we can match against,\n          // i.e., all but the one we just matched against\n          var qx = [];\n          for (var j = 0; j < px.length ; j++) {\n            if (i !== j) {\n              qx.push(px[j]);\n            }\n          }\n\n          // now invoke recursively set with the remaining input\n          // note that we don't include the closing delimiter ...\n          // we'll check for that ourselves at the end\n          p = o.set(qx, d).call(this, q[1]);\n\n          // if we got a non-empty set as a result ...\n          // (otw rx already contains everything we want to match)\n          if (p[0].length > 0) {\n            // update current result, which is stored in rx ...\n            // basically, pick up the remaining text from p[1]\n            // and concat the result from p[0] so that we don't\n            // get endless nesting ...\n            rx[0] = rx[0].concat(p[0]);\n            rx[1] = p[1];\n          }\n        }\n\n        // at this point, rx either contains the last matched element\n        // or the entire matched set that starts with this element.\n\n        // now we just check to see if this variation is better than\n        // our best so far, in terms of how much of the input is parsed\n        if (rx[1].length < best[1].length) {\n          best = rx;\n        }\n\n        // if we've parsed all the input, then we're finished\n        if (best[1].length === 0) {\n          break;\n        }\n      }\n\n      // so now we've either gone through all the patterns trying them\n      // as the initial match; or we found one that parsed the entire\n      // input string ...\n\n      // if best has no matches, just return empty set ...\n      if (best[0].length === 0) {\n        return best;\n      }\n\n      // if a closing delimiter is provided, then we have to check it also\n      if (c) {\n        // we try this even if there is no remaining input because the pattern\n        // may well be optional or match empty input ...\n        try {\n          q = c.call(this, best[1]);\n        } catch (ey) {\n          throw new $P.Exception(best[1]);\n        }\n\n        // it parsed ... be sure to update the best match remaining input\n        best[1] = q[1];\n      }\n\n      // if we're here, either there was no closing delimiter or we parsed it\n      // so now we have the best match; just return it!\n      return best;\n    };\n  },\n  forward: function(gr, fname) {\n    return function(s) {\n      return gr[fname].call(this, s);\n    };\n  },\n\n  //\n  // Translation Operators\n  //\n  replace: function(rule, repl) {\n    return function(s) {\n      var r = rule.call(this, s);\n      return [repl, r[1]];\n    };\n  },\n  process: function(rule, fn) {\n    return function(s) {\n      var r = rule.call(this, s);\n      return [fn.call(this, r[0]), r[1]];\n    };\n  },\n  min: function(min, rule) {\n    return function(s) {\n      var rx = rule.call(this, s);\n      if (rx[0].length < min) {\n        throw new $P.Exception(s);\n      }\n      return rx;\n    };\n  }\n};\n\n// Generator Operators And Vector Operators\n\n// Generators are operators that have a signature of F(R) => R,\n// taking a given rule and returning another rule, such as\n// ignore, which parses a given rule and throws away the result.\n\n// Vector operators are those that have a signature of F(R1,R2,...) => R,\n// take a list of rules and returning a new rule, such as each.\n\n// Generator operators are converted (via the following xgenerator\n// function) into functions that can also take a list or array of rules\n// and return an array of new rules as though the function had been\n// called on each rule in turn (which is what actually happens).\n\n// This allows generators to be used with vector operators more easily.\n// Example:\n// each(ignore(foo, bar)) instead of each(ignore(foo), ignore(bar))\n\n// This also turns generators into vector operators, which allows\n// constructs like:\n// not(cache(foo, bar))\n\nfunction xgenerator(op) {\n  return function() {\n    var args = null, rx = [];\n    if (arguments.length > 1) {\n      args = Array.prototype.slice.call(arguments);\n    } else if (arguments[0] instanceof Array) {\n      args = arguments[0];\n    }\n    if (args) {\n      if (args.length) {\n        var px = args.shift();\n        args.unshift(px[0]);\n        rx.push(op.apply(null, args));\n        args.shift();\n        return rx;\n      }\n    } else {\n      return op.apply(null, arguments);\n    }\n  };\n}\n\nfunction xvector(op) {\n  return function() {\n    if (arguments[0] instanceof Array) {\n      return op.apply(null, arguments[0]);\n    } else {\n      return op.apply(null, arguments);\n    }\n  };\n}\n\nfunction $w(s, fn) {\n  var w = s.split(\" \");\n  for (var i = 0; i < w.length; i++) {\n    fn(w[i]);\n  }\n}\n\n$w(\"optional not ignore cache\", function(s) {\n  o[s] = xgenerator(o[s]);\n});\n$w(\"vtoken each any all\", function(s) {\n  o[s] = xvector(o[s]);\n});\n\nmodule.exports = Parser;\n"]}